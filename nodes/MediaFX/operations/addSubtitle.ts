import { IExecuteFunctions, NodeOperationError, IDataObject } from 'n8n-workflow';
import * as path from 'path';
import * as fs from 'fs-extra';
import * as os from 'os';
import ffmpeg = require('fluent-ffmpeg');
import { getTempFile, runFfmpeg, getAvailableFonts, getVideoStreamInfo, getFontByPath } from '../utils';

/**
 * Escape special characters in file path for FFmpeg subtitles filter.
 */
function escapeSubtitlePath(filePath: string): string {
	// For Windows paths and special characters
	return filePath
		.replace(/\\/g, '/')
		.replace(/:/g, '\\:')
		.replace(/'/g, "'\\''");
}

/**
 * Convert color to ASS format (&HAABBGGRR)
 */
function colorToASS(color: string, opacity: number = 1): string {
	let r = 'FF', g = 'FF', b = 'FF';
	
	if (color && color.startsWith('#') && color.length === 7) {
		r = color.substring(1, 3);
		g = color.substring(3, 5);
		b = color.substring(5, 7);
	} else {
		const namedColors: Record<string, string> = {
			white: 'FFFFFF',
			black: '000000',
			red: 'FF0000',
			green: '00FF00',
			blue: '0000FF',
			yellow: 'FFFF00',
			cyan: '00FFFF',
			magenta: 'FF00FF',
			orange: 'FFA500',
		};
		const hex = namedColors[(color || 'white').toLowerCase()] || 'FFFFFF';
		r = hex.substring(0, 2);
		g = hex.substring(2, 4);
		b = hex.substring(4, 6);
	}
	
	// ASS format: &HAABBGGRR (AA = alpha, 00=solid, FF=transparent)
	const alpha = Math.round((1 - opacity) * 255).toString(16).padStart(2, '0').toUpperCase();
	return `&H${alpha}${b}${g}${r}`.toUpperCase();
}

/**
 * Get ASS alignment number (numpad style)
 * 7=top-left, 8=top-center, 9=top-right
 * 4=middle-left, 5=middle-center, 6=middle-right
 * 1=bottom-left, 2=bottom-center, 3=bottom-right
 */
function getASSAlignment(horizontalAlign: string, verticalAlign: string): number {
	const alignMap: Record<string, Record<string, number>> = {
		top: { left: 7, center: 8, right: 9 },
		middle: { left: 4, center: 5, right: 6 },
		bottom: { left: 1, center: 2, right: 3 },
	};
	return alignMap[verticalAlign]?.[horizontalAlign] ?? 2;
}

/**
 * Check if file is ASS/SSA format
 */
function isASSFile(filePath: string): boolean {
	const ext = path.extname(filePath).toLowerCase();
	return ext === '.ass' || ext === '.ssa';
}

/**
 * Add horizontal padding to subtitle text for background box mode.
 * ASS doesn't support native padding, so we use transparent spaces with \h (hard space).
 * The padding is achieved by adding non-breaking spaces before and after the text.
 */
function addTextPadding(text: string, paddingSpaces: number): string {
	if (paddingSpaces <= 0) return text;
	
	// \h is ASS hard space (non-breaking space that takes up visual space)
	const padding = '\\h'.repeat(paddingSpaces);
	
	// Handle multi-line subtitles (separated by \N)
	const lines = text.split('\\N');
	const paddedLines = lines.map(line => `${padding}${line}${padding}`);
	return paddedLines.join('\\N');
}

/**
 * Convert SRT content to ASS format with full styling support
 */
function convertSRTtoASS(
	srtContent: string,
	fontName: string,
	fontSize: number,
	primaryColor: string,
	outlineColor: string,
	outlineWidth: number,
	backColor: string,
	enableBackground: boolean,
	alignment: number,
	marginV: number,
	marginL: number,
	marginR: number,
	videoWidth: number,
	videoHeight: number,
): string {
	// BorderStyle=3 enables opaque box mode where BackColour determines the box color
	// IMPORTANT: When BorderStyle=3, Outline MUST be 0, otherwise it overrides BackColour transparency
	// Shadow must be 1 for the background box to display properly
	let borderStyle: number;
	let outline: number;
	let shadow: number;
	let effectiveOutlineColor: string;
	
	if (enableBackground) {
		borderStyle = 3;    // Opaque box mode - BackColour becomes the box background
		outline = 0;        // MUST be 0, non-zero overrides BackColour
		shadow = 1;         // MUST be 1 for box to display
		effectiveOutlineColor = backColor;
	} else {
		borderStyle = 1;    // Normal outline mode
		outline = outlineWidth;
		shadow = 0;
		effectiveOutlineColor = outlineColor;
	}

	const header = `[Script Info]
Title: Generated by MediaFX
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
PlayResX: ${videoWidth}
PlayResY: ${videoHeight}

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,${fontName},${fontSize},${primaryColor},${primaryColor},${effectiveOutlineColor},${backColor},0,0,0,0,100,100,0,0,${borderStyle},${outline},${shadow},${alignment},${marginL},${marginR},${marginV},1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`;

	// Parse SRT blocks
	const blocks = srtContent.trim().split(/\r?\n\r?\n/);
	const dialogues: string[] = [];
	
	// Calculate padding spaces based on font size (approximately 0.5em worth of padding)
	// Smaller fonts need fewer spaces, larger fonts need more
	const paddingSpaces = enableBackground ? Math.max(2, Math.round(fontSize / 24)) : 0;

	for (const block of blocks) {
		const lines = block.trim().split(/\r?\n/);
		if (lines.length < 2) continue;

		// Find timestamp line (may be first or second line)
		let timestampLine = '';
		let textStartIndex = 0;
		
		for (let i = 0; i < lines.length; i++) {
			if (lines[i].includes('-->')) {
				timestampLine = lines[i];
				textStartIndex = i + 1;
				break;
			}
		}

		if (!timestampLine) continue;

		// Parse timestamps: 00:00:01,000 --> 00:00:04,000
		const match = timestampLine.match(
			/(\d{1,2}):(\d{2}):(\d{2})[,.](\d{3})\s*-->\s*(\d{1,2}):(\d{2}):(\d{2})[,.](\d{3})/
		);
		if (!match) continue;

		// Convert to ASS time format: H:MM:SS.cc
		const startTime = `${parseInt(match[1])}:${match[2]}:${match[3]}.${match[4].substring(0, 2)}`;
		const endTime = `${parseInt(match[5])}:${match[6]}:${match[7]}.${match[8].substring(0, 2)}`;

		// Get subtitle text (remaining lines)
		let text = lines.slice(textStartIndex).join('\\N');
		
		// Add horizontal padding when background is enabled
		if (enableBackground && text.trim()) {
			text = addTextPadding(text, paddingSpaces);
		}

		if (text.trim()) {
			dialogues.push(`Dialogue: 0,${startTime},${endTime},Default,,0,0,0,,${text}`);
		}
	}

	return header + dialogues.join('\n') + '\n';
}

export async function executeAddSubtitle(
	this: IExecuteFunctions,
	video: string,
	subtitleFile: string,
	style: IDataObject,
	itemIndex: number,
): Promise<string> {
	const outputPath = getTempFile(path.extname(video));

	// 1. Get Font (support both bundled and system fonts)
	const fontSource = (style.fontSource as string) || 'bundled';
	let font: IDataObject | null = null;

	if (fontSource === 'system') {
		const systemFontPath = style.systemFontPath as string;
		if (!systemFontPath) {
			throw new NodeOperationError(
				this.getNode(),
				'System font path is required when using system fonts.',
				{ itemIndex },
			);
		}
		font = getFontByPath(systemFontPath);
		if (!font) {
			throw new NodeOperationError(
				this.getNode(),
				`System font not found at path '${systemFontPath}'. Please check the path and ensure it's a valid font file (TTF, OTF, TTC).`,
				{ itemIndex },
			);
		}
	} else {
		const allFonts = getAvailableFonts();
		const fontKey = (style.fontKey as string) || 'noto-sans-kr';
		font = allFonts[fontKey] as IDataObject | undefined || null;

		if (!font || !font.path) {
			throw new NodeOperationError(
				this.getNode(),
				`Selected font key '${fontKey}' is not valid or its file path is missing.`,
				{ itemIndex },
			);
		}
	}

	const fontName = (font.name as string) || 'Sans';
	const fontSize = (style.size as number) || 48;
	const fontColor = (style.color as string) || 'white';
	const outlineWidth = (style.outlineWidth as number) ?? 1;
	const outlineColor = (style.outlineColor as string) || 'black';
	const enableBackground = (style.enableBackground as boolean) ?? false;
	const backgroundColor = (style.backgroundColor as string) || 'black';
	const backgroundOpacity = (style.backgroundOpacity as number) ?? 0.5;

	// 2. Get alignment and padding
	const positionType = style.positionType || 'alignment';
	let horizontalAlign = 'center';
	let verticalAlign = 'bottom';
	let paddingX = 20;
	let paddingY = 20;

	if (positionType === 'alignment') {
		horizontalAlign = (style.horizontalAlign as string) || 'center';
		verticalAlign = (style.verticalAlign as string) || 'bottom';
		paddingX = (style.paddingX as number) ?? 20;
		paddingY = (style.paddingY as number) ?? 20;
	}

	const alignment = getASSAlignment(horizontalAlign, verticalAlign);

	// 3. Convert colors to ASS format
	const primaryColorASS = colorToASS(fontColor, 1);
	const outlineColorASS = colorToASS(outlineColor, 1);
	const backColorASS = colorToASS(backgroundColor, backgroundOpacity);

	// 4. Get video dimensions
	let videoWidth = 1080;
	let videoHeight = 1920;
	try {
		const videoInfo = await getVideoStreamInfo(video);
		if (videoInfo && videoInfo.width && videoInfo.height) {
			videoWidth = videoInfo.width;
			videoHeight = videoInfo.height;
		}
	} catch (e) {
		// Use default if ffprobe fails
	}

	// 5. Prepare subtitle file
	let finalSubtitlePath = subtitleFile;
	let tempAssFile: string | null = null;

	if (isASSFile(subtitleFile)) {
		// ASS/SSA file: use directly
		finalSubtitlePath = subtitleFile;
	} else {
		// SRT file: convert to ASS for full styling support
		const srtContent = await fs.readFile(subtitleFile, 'utf-8');
		const assContent = convertSRTtoASS(
			srtContent,
			fontName,
			fontSize,
			primaryColorASS,
			outlineColorASS,
			outlineWidth,
			backColorASS,
			enableBackground,
			alignment,
			paddingY,
			paddingX,
			paddingX,
			videoWidth,
			videoHeight,
		);

		// Create temp ASS file with unique name
		tempAssFile = path.join(os.tmpdir(), `mediafx_sub_${Date.now()}_${Math.random().toString(36).substring(7)}.ass`);
		await fs.writeFile(tempAssFile, assContent, 'utf-8');
		finalSubtitlePath = tempAssFile;
		
		// Debug: log ASS content for troubleshooting
		console.log('[MediaFX] enableBackground:', enableBackground, 'type:', typeof enableBackground);
		console.log('[MediaFX] style.enableBackground raw:', style.enableBackground);
		console.log('[MediaFX] Generated ASS file:', tempAssFile);
		console.log('[MediaFX] ASS Style line:', assContent.split('\n').find(line => line.startsWith('Style:')));
	}

	// 5. Build FFmpeg command with fontsdir for custom fonts
	const escapedPath = escapeSubtitlePath(finalSubtitlePath);
	const fontPath = font.path as string;
	const fontDir = escapeSubtitlePath(path.dirname(fontPath));
	const subtitlesFilter = `ass='${escapedPath}':fontsdir='${fontDir}'`;

	const command = ffmpeg(video)
		.videoFilters([subtitlesFilter])
		.audioCodec('copy')
		.save(outputPath);

	try {
		await runFfmpeg(command);
		return outputPath;
	} catch (error) {
		await fs.remove(outputPath).catch(() => {});
		throw new NodeOperationError(
			this.getNode(),
			`Error adding subtitles to video. FFmpeg error: ${(error as Error).message}`,
			{ itemIndex },
		);
	} finally {
		// Clean up temp ASS file
		if (tempAssFile) {
			await fs.remove(tempAssFile).catch(() => {});
		}
	}
}
